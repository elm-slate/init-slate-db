# slate-init-db
Creates and initializes a Postgresql database for use by Slate applications, e.g. [`slate-replicator`](https://github.com/panosoft/slate-replicator).

The purpose of slate-init-db is to create and initialize a new `Postgresql` database to contain either a `source` or `destination` events table (see [`Database Initialization`](#databaseInitialization)).

# Installation
> npm install -g @panosoft/slate-init-db

# Usage

#### Run slate-init-db

    slate-init-db [options]

    Options:

      -h, --help                               output usage information
      --host <name>                            database server name
      --user <name>                            database user name.  must have database creation privileges.  if not specified, prompt for user name.
      --password <password>                    database password.  if not specified, prompt for password.
      --connect-timeout <millisecs>            database connection timeout.  if not specified, defaults to 15000 millisecs.
      -n, --new-database <name>                name of database to create
      -t, --table-type <source | destination>  type of events table to create in new database:  must be "source"  or "destination"
      --dry-run                                if specified, display run parameters and end program without performing database initialization

# Operations
### Start up validations
- Run options are validated
- Database to be created must NOT exist and its name must be a valid `Postgresql` identifier
- If `slate-init-db` is started in `--dry-run` mode then it will validate and display run options without performing database initialization
- All start up information and any options errors are logged

### Error Recovery
- All operational errors will be logged
- If errors are reported when running `slate-init-db` then the new database was not initialized properly and MUST be deleted manually before re-running.

<a href="databaseInitialization"></a>
# Database Initialization
Initialization differs depending on the `table-type`.

When creating a `source` database, the following source-only database objects are created: an `id` table, an `insert_events` function, an `events` table trigger and its trigger function.

The `id` table in a `source` database is used to assign ids to the rows as they are inserted into the `events` table by the `insert_events` function. The ids start at 1 and are guaranteed to be consecutive.

The `id` and `ts` column values in a `source` events table row are generated by the `insert_events` function. This means that the singleton `source` database is the master clock for all events.

## Database Initialization Details

### Source and Destination

```sql
--create events table

CREATE TABLE events
(
  id bigint NOT NULL,
  ts timestamp with time zone NOT NULL,
  entity_id uuid NOT NULL,
  event jsonb NOT NULL,
  CONSTRAINT events_pkey PRIMARY KEY (id)
)
WITH (
  OIDS=FALSE
);

--create events table indexes

CREATE INDEX events_event_name on events ((event #>> '{name}'));

CREATE INDEX events_ts on events (ts);

CREATE INDEX events_entity_id on events (entity_id);
```

### Source ONLY

#### Events Table trigger and trigger function (the trigger and trigger function do not exist in a destination database)

```sql
--create NOTIFY trigger function

CREATE FUNCTION events_notify_trigger() RETURNS trigger AS $$
DECLARE
BEGIN
  PERFORM pg_notify('eventsinsert', json_build_object('table', TG_TABLE_NAME, 'id', NEW.id )::text);
  RETURN new;
END;
$$ LANGUAGE plpgsql;

--create NOTIFY trigger

CREATE TRIGGER events_table_trigger AFTER INSERT ON events
FOR EACH ROW EXECUTE PROCEDURE events_notify_trigger();
```

#### ID Table Initialization (this table does not exist in a destination database)

```sql
CREATE TABLE id (
  id bigint NOT NULL,
  CONSTRAINT id_pkey PRIMARY KEY (id))
WITH (
  OIDS=FALSE
);
```
#### insert_events function (this function does not exist in a destination database)

```sql
CREATE FUNCTION insert_events(insertValues text)
	RETURNS integer AS $$
DECLARE
	ts timestamp with time zone;
	startId bigint;
	nextStartId bigint;
	idxs bigint[];
	ids bigint[];
	lastIdx integer;
	idx bigint;
	rowsInserted bigint;
	countRows bigint;
	maxIndex bigint;
	tsMatches text[];
BEGIN
	LOCK TABLE ID IN ACCESS EXCLUSIVE MODE;
	-- get timestamp to insert in each ts column
	ts := transaction_timestamp();
	-- insertValues is a string value that represents the column values to insert for one or more rows for one INSERT statement.
	-- insertValues is formatted to follow the VALUES keyword of the statement "INSERT INTO events (id, ts, entity_id, event) VALUES "
	-- (e.g. '($1[1], $2, '<entity_id literal>', '<json string for event>'),($1[2], $2, '<entity_id literal>', '<json string for event>')'.
	-- The id column for each row to insert is formatted as a substitution parameter, $1[x], where x is an index value.
	-- index values start at 1 for the first row to insert and must be a consecutive positive integer for each additional row.
	-- The ts (event timestamp) column is generated by this function and is represented  by the parameter $2.

	SELECT ARRAY(SELECT unnest(regexp_matches(insertValues, '\$1\[([0-9]+)\]', 'g'))) into idxs;
	SELECT ARRAY(SELECT unnest(regexp_matches(insertValues, '(\$2),', 'g'))) into tsMatches;
	countRows := 0;
	lastIdx := 0;
	-- find the row count, maximum index for a row, and check that the indices are consecutive positive integers.
	FOREACH idx IN ARRAY idxs
	LOOP
		countRows := countRows + 1;
		IF lastIdx = 0 THEN
			lastIdx := idx;
		ELSE
			IF idx = lastIdx + 1 THEN
				lastIdx := idx;
				maxIndex := idx;
			ELSE
				RAISE EXCEPTION 'Parameter index is not consecutive at ------> %,  previous index ------> %', idx, lastIdx
					USING HINT = 'Parameter for id column of the form "$1[x]" where x is the 1-based index for the row to be inserted is not greater than the previous row''s index';
			END IF;
		END IF;
	END LOOP;
	IF countRows < 1 THEN
		RAISE EXCEPTION 'No inserted rows found with id substitution parameters' USING HINT = 'id column substitution parameter value for row to be inserted must be of the form "$1[x]" where x is the 1-indexed based index of the row';
	END IF;
	IF countRows != maxIndex THEN
		RAISE EXCEPTION 'Number of rows to be inserted (%) does not match the highest row index (%)', countRows, maxIndex USING HINT = 'The highest id column parameter substitution parameter index value does not match the number of rows to be inserted';
	END IF;
	IF countRows != coalesce(array_length(tsMatches, 1), 0) THEN
		RAISE EXCEPTION 'Number of rows to be inserted (%) does not match number of rows with a ts substitution parameter (%)', countRows, coalesce(array_length(tsMatches, 1), 0) USING HINT = 'ts column parameter substitution value for row to be inserted must be "$2"';
	END IF;

	-- update id table to point to the next starting id value to use
	UPDATE id SET id = id + countRows RETURNING id INTO nextStartId;
	-- start id for first insert statement
	startId := nextStartId - countRows;
	-- get ids to use for each inserted row's id column
	SELECT into ids ARRAY(SELECT generate_series(startId, nextStartId - 1));
	-- RAISE NOTICE 'ids ----> %', ids;
	EXECUTE 'INSERT INTO events (id, ts, entity_id, event) VALUES ' || insertValues USING ids, ts;
	GET DIAGNOSTICS rowsInserted = ROW_COUNT;
	RETURN rowsInserted;
END;
$$ LANGUAGE plpgsql;
```
